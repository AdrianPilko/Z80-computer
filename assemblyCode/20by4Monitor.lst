0001   0000             ;; Adrian Pilkington December 2023
0002   0000             ;; this is written to run on the single board homebrew computer described 
0003   0000             ;; by the schematics in this repo.
0004   0000             
0005   0000             ;;; memory model:
0006   0000             ;;; 0x0000 to 7fff      - ROM
0007   0000             ;;; 0x8000 to to 0xffff - RAM
0008   0000             ;;; 
0009   0000             #define ROM_SIZE $7fff
0010   0000             #define SIZE_OF_SYSTEM_VARIABLES $0004
0011   0000             #define STACK_BOTTOM $ffff
0012   0000             #define RAM_START $8000  
0013   0000             #define DISPLAY_COLS 19
0014   0000             
0015   0000             ;; port definitions
0016   0000             #define lcdRegisterSelectCommand $00   ; all zero address including line 0 which is connected to the LCD  ReadSelect (RS) pin 
0017   0000             #define lcdRegisterSelectData $01      ; all zero address except line 0 which is connected to the LCD  ReadSelect (RS) pin 
0018   0000             #define keypadInOutPort $20             ; A6 high the rest low
0019   0000             
0020   0000                 .org $0
0021   0000                 
0022   0000 31 FF FF        ld  sp , STACK_BOTTOM 
0023   0003                 
0024   0003 CD 90 00        call initialiseLCD
0025   0006             
0026   0006 AF              xor a
0027   0007 32 00 80        ld (currentDisplayRow), a
0028   000A 32 01 80        ld (currentDisplayCol), a
0029   000D                 
0030   000D AF              xor a
0031   000E 32 5D 01        ld (rowcount), a
0032   0011 32 5E 01        ld (rowcount+1), a
0033   0014                 
0034   0014             mainLoop  
0035   0014 CD 47 00        call arduinoInputScan
0036   0017                 ;; e now contains the byte read in if any, could be zero
0037   0017 1C              inc e 
0038   0018 1D              dec e    
0039   0019 28 F9           jr z, mainLoop
0040   001B CD 3E 00        call displayChar    
0041   001E 18 F4           jr mainLoop
0042   0020                 
0043   0020 76              halt   ; should never reach this
0044   0021                       
0045   0021             writeTextToDisplay:    ; this always prints the contnets of DisplayBuffer
0046   0021 21 8C 01        ld hl, DisplayBuffer
0047   0024 01 13 00        ld bc, 19
0048   0027             WriteRow:           
0049   0027 C5              push bc
0050   0028 E5                  push hl       
0051   0029 CD BB 00                call waitLCD
0052   002C E1                  pop hl
0053   002D 7E                  ld a, (hl)
0054   002E D3 01               out (lcdRegisterSelectData), a
0055   0030 23                  inc hl
0056   0031 C1              pop bc
0057   0032 10 F3           djnz WriteRow 
0058   0034 C9              ret
0059   0035                 
0060   0035             copyToDisplayBuffer_hl_b:    
0061   0035 11 8C 01        ld de, DisplayBuffer
0062   0038 48              ld c, b
0063   0039 06 00           ld b, 0
0064   003B ED B0           ldir
0065   003D C9              ret
0066   003E             
0067   003E             displayChar
0068   003E F5              push af
0069   003F CD BB 00        call waitLCD
0070   0042 7B              ld a, e
0071   0043 D3 01           out (lcdRegisterSelectData), a
0072   0045 F1              pop af    
0073   0046 C9              ret    
0074   0047                
0075   0047                 
0076   0047             arduinoInputScan  
0077   0047 CD 6C 00        call giveArduinoAChance_1
0078   004A CD 6C 00        call giveArduinoAChance_1
0079   004D CD 6C 00        call giveArduinoAChance_1
0080   0050 CD 6C 00        call giveArduinoAChance_1
0081   0053 CD 6C 00        call giveArduinoAChance_1
0082   0056 CD 6C 00        call giveArduinoAChance_1
0083   0059                 
0084   0059 CD 79 00        call giveArduinoAChance_2
0085   005C CD 79 00        call giveArduinoAChance_2
0086   005F CD 79 00        call giveArduinoAChance_2
0087   0062 CD 79 00        call giveArduinoAChance_2
0088   0065 CD 79 00        call giveArduinoAChance_2
0089   0068 CD 79 00        call giveArduinoAChance_2
0090   006B C9              ret
0091   006C                 
0092   006C             giveArduinoAChance_1
0093   006C 0E 20           ld c, keypadInOutPort    
0094   006E 3E 01           ld a,1      ; bit zero on out port    
0095   0070 06 FF           ld b, 255    
0096   0072             giveChanceLoop1    
0097   0072 ED 79           out (c), a    ; output 1 on the ready to rx pin    
0098   0074 ED 58           in e, (c)     ; read in 1 byte into e from the keyboard port (now used as arduino "keyboard emulator"
0099   0076 10 FA           djnz giveChanceLoop1
0100   0078 C9              ret
0101   0079             
0102   0079             giveArduinoAChance_2
0103   0079 0E 20           ld c, keypadInOutPort   
0104   007B AF              xor a
0105   007C 06 FF           ld b, 255
0106   007E             giveChanceLoop2
0107   007E ED 79           out (c), a    ; set ready rx pin to off
0108   0080 10 FC           djnz giveChanceLoop2
0109   0082 C9              ret
0110   0083             
0111   0083             
0112   0083                 
0113   0083             delaySome:    
0114   0083 C5              push bc    ; preserve bc register
0115   0084 06 FF           ld b, $ff
0116   0086             waitLoopAfterKeyFound11:    
0117   0086 C5              push bc
0118   0087 06 1F           ld b, $1f
0119   0089             waitLoopAfterKeyFound22:        
0120   0089 10 FE           djnz waitLoopAfterKeyFound22
0121   008B C1              pop bc
0122   008C 10 F8           djnz waitLoopAfterKeyFound11    
0123   008E C1              pop bc
0124   008F C9              ret
0125   0090              
0126   0090                   
0127   0090               
0128   0090             initialiseLCD:
0129   0090 21 21 01        ld hl,InitCommandList
0130   0093 CD BB 00        call waitLCD
0131   0096             loopLCDInitCommands
0132   0096 7E              ld a, (hl)
0133   0097 FE FF           cp $ff
0134   0099 CA A2 00        jp z, initialiseLCD_ret
0135   009C D3 00           out (lcdRegisterSelectCommand), a     ; send command to lcd (assuming lcd control port is at 0x00)
0136   009E 23              inc hl
0137   009F C3 96 00        jp loopLCDInitCommands    
0138   00A2             initialiseLCD_ret    
0139   00A2 C9              ret
0140   00A3             
0141   00A3             ;;; "generic" display code
0142   00A3             ; self evident, this clears the display
0143   00A3             clearDisplay:
0144   00A3 F5              push af
0145   00A4 CD BB 00        call waitLCD
0146   00A7 3E 01       	ld a, $01
0147   00A9 32 00 00    	ld (lcdRegisterSelectCommand), a
0148   00AC F1              pop af
0149   00AD C9          	ret 
0150   00AE             
0151   00AE             ;Row	DDRAM Start Address	Set DDRAM Command (Hex)
0152   00AE             ;1	0x00	0x80   (after oring with 0x80)
0153   00AE             ;2	0x40	0xC0
0154   00AE             ;3	0x14	0x94
0155   00AE             ;4	0x54	0xD4
0156   00AE              
0157   00AE             setLCDRowCol_bc:   ; set b to row, c to column
0158   00AE C5              push bc
0159   00AF CD BB 00        call waitLCD
0160   00B2 C1              pop bc
0161   00B3 78              ld a, b
0162   00B4 81              add a, c           ; add the column
0163   00B5 16 80           ld d, $80       ; ddram command 
0164   00B7 B2              or d   
0165   00B8 D3 00           out (lcdRegisterSelectCommand), a     ; Send command to LCD         
0166   00BA C9              ret 
0167   00BB             
0168   00BB             ;;; make sure the lcd isn't busy - by checking the busy flag
0169   00BB             waitLCD:    
0170   00BB F5              push af
0171   00BC             waitForLCDLoop:             
0172   00BC DB 00           in a,(lcdRegisterSelectCommand)  
0173   00BE 07              rlca              
0174   00BF 38 FB           jr c,waitForLCDLoop    
0175   00C1 F1              pop af
0176   00C2 C9              ret 
0177   00C3                 
0178   00C3             displayCharacter:    ; register a stores tghe character
0179   00C3 CD BB 00        call waitLCD
0180   00C6 D3 01           out (lcdRegisterSelectData), a
0181   00C8 C9              ret 
0182   00C9             
0183   00C9             hexprint16_onRight
0184   00C9 CD BB 00        call waitLCD
0185   00CC 3E C9           ld a, $80+$49        ; Set DDRAM address to start line 2 plus 5
0186   00CE D3 00           out (lcdRegisterSelectCommand), a     ; Send command to LCD    
0187   00D0 CD D4 00        call hexprint16
0188   00D3                 
0189   00D3 C9              ret
0190   00D4             
0191   00D4                 
0192   00D4             hexprint16  ; print one 2byte number stored in location $to_print modified from hprint http://swensont.epizy.com/ZX81Assembly.pdf?i=1
0193   00D4             	;ld hl,$ffff  ; debug check conversion to ascii
0194   00D4                 ;ld ($to_print), hl
0195   00D4                 
0196   00D4 21 03 80    	ld hl,$to_print+$01	
0197   00D7 06 02       	ld b,2	
0198   00D9             hexprint16_loop	
0199   00D9 CD BB 00        call waitLCD    
0200   00DC 7E          	ld a, (hl)
0201   00DD F5          	push af ;store the original value of a for later
0202   00DE E6 F0       	and $f0 ; isolate the first digit
0203   00E0 0F          	rrca
0204   00E1 0F          	rrca
0205   00E2 0F          	rrca
0206   00E3 0F          	rrca        
0207   00E4 CD 15 01        call ConvertToASCII
0208   00E7 D3 01       	out (lcdRegisterSelectData), a
0209   00E9 CD BB 00        call waitLCD 
0210   00EC F1          	pop af ; retrieve original value of a
0211   00ED E6 0F       	and $0f ; isolate the second digit
0212   00EF CD 15 01        call ConvertToASCII       
0213   00F2 D3 01       	out (lcdRegisterSelectData), a
0214   00F4 2B          	dec hl
0215   00F5 10 E2       	djnz hexprint16_loop
0216   00F7 C9          	ret	  
0217   00F8             
0218   00F8             hexprint8 		
0219   00F8 F5          	push af ;store the original value of a for later
0220   00F9 CD BB 00        call waitLCD 
0221   00FC F1              pop af
0222   00FD F5              push af ;store the original value of a for later
0223   00FE E6 F0       	and $f0 ; isolate the first digit    
0224   0100 0F          	rrca
0225   0101 0F          	rrca
0226   0102 0F          	rrca
0227   0103 0F          	rrca  
0228   0104 CD 15 01        call ConvertToASCII
0229   0107 D3 01       	out (lcdRegisterSelectData), a
0230   0109 CD BB 00        call waitLCD 
0231   010C F1          	pop af ; retrieve original value of a
0232   010D E6 0F       	and $0f ; isolate the second digit
0233   010F CD 15 01        call ConvertToASCII       
0234   0112 D3 01       	out (lcdRegisterSelectData), a
0235   0114 C9          	ret
0236   0115             
0237   0115             ConvertToASCII:
0238   0115                 ; assuming the value in register a (0-15) to be converted to ascii
0239   0115                 ; convert the value to its ascii representation
0240   0115 C6 30           add a, '0'       ; convert value to ascii character
0241   0117 FE 3A           cp  ':'        ; compare with ascii '9'
0242   0119 30 03           jr  nc, ConvertToASCIIdoAdd     ; jump if the value is not between 0-9
0243   011B C3 20 01        jp ConvertToASCII_ret
0244   011E             ConvertToASCIIdoAdd:    
0245   011E C6 07           add a, 7     ; if greater than '9', adjust to ascii a-f
0246   0120             ConvertToASCII_ret:
0247   0120                     
0248   0120 C9              ret              ; return from subroutine
0249   0121                 
0250   0121             
0251   0121             ;;; rom "constants"
0252   0121             
0253   0121             InitCommandList:
0254   0121             ;            4 line mode
0255   0121             ;            |       clear display
0256   0121             ;            |       |   cursor auto increment
0257   0121             ;            |       |   |
0258   0121 38 0E 01 06     .db $38,$0e,$01,$06,$ff
0258   0125 FF 
0259   0126             ;   .db $38,$09,$0e,$01,$06,$ff
0260   0126                     
0261   0126             
0262   0126             
0263   0126             ;Step	Command (Hex)	Description
0264   0126             ;1	0x33	Initialize in 8-bit mode (repeated to ensure).
0265   0126             ;2	0x32	Switch to 4-bit mode.
0266   0126             ;3	0x28	Function set: 4-bit mode, 2 lines, 5x8 dots.
0267   0126             ;4	0x0C	Display ON, Cursor OFF, Blink OFF.
0268   0126             ;5	0x01	Clear display.
0269   0126             ;6	0x06	Entry mode: Increment, No shift.        
0270   0126             ;    .db $33, $33, $32, $28, $01, $06
0271   0126             
0272   0126             RowAddresses:
0273   0126 00 40 14 54     .db $00,$40,$14,$54
0274   012A             BootMessage:
0275   012A 5A 38 30 20     .db "Z80 byteForever",$ff    
0275   012E 62 79 74 65 
0275   0132 46 6F 72 65 
0275   0136 76 65 72 FF 
0276   013A             
0277   013A             TestMessageRow1
0278   013A 48 65 6C 6C     .db "Hello,World!",$ff    
0278   013E 6F 2C 57 6F 
0278   0142 72 6C 64 21 
0278   0146 FF 
0279   0147             TestMessageRow2   
0280   0147 42 79 74 65     .db "ByteForever",$ff        
0280   014B 46 6F 72 65 
0280   014F 76 65 72 FF 
0281   0153             TestMessageRow3    
0282   0153 33 33 33 33     .db "3333",$ff    
0282   0157 FF 
0283   0158             TestMessageRow4    
0284   0158 34 34 34 34     .db "4444",$ff    
0284   015C FF 
0285   015D             rowcount
0286   015D 00 00           .dw $0000
0287   015F             DisplayBufferProtectZone
0288   015F 20 20 20 20     .db "                                             "
0288   0163 20 20 20 20 
0288   0167 20 20 20 20 
0288   016B 20 20 20 20 
0288   016F 20 20 20 20 
0288   0173 20 20 20 20 
0288   0177 20 20 20 20 
0288   017B 20 20 20 20 
0288   017F 20 20 20 20 
0288   0183 20 20 20 20 
0288   0187 20 20 20 20 
0288   018B 20 
0289   018C                     
0290   018C             DisplayBuffer    ; this is big enough to fit one complete row, $ff terminates
0291   018C 2A 2A 2A 2A     .db "*****************",$ff,$ff,$ff,$ff,$ff,$ff,$ff
0291   0190 2A 2A 2A 2A 
0291   0194 2A 2A 2A 2A 
0291   0198 2A 2A 2A 2A 
0291   019C 2A FF FF FF 
0291   01A0 FF FF FF FF 
0292   01A4             DisplayBufferProtectZone2
0293   01A4 20 20 20 20     .db "                                             "    
0293   01A8 20 20 20 20 
0293   01AC 20 20 20 20 
0293   01B0 20 20 20 20 
0293   01B4 20 20 20 20 
0293   01B8 20 20 20 20 
0293   01BC 20 20 20 20 
0293   01C0 20 20 20 20 
0293   01C4 20 20 20 20 
0293   01C8 20 20 20 20 
0293   01CC 20 20 20 20 
0293   01D0 20 
0294   01D1             ;;; ram variables    
0295   8000                 .org RAM_START
0296   8000             currentDisplayRow
0297   8000 00              .db $00
0298   8001             currentDisplayCol
0299   8001 00              .db $00   
0300   8002             to_print:
0301   8002 00 00           .dw $0000
0302   8004             #END
0303   8004             
tasm: Number of errors = 0
